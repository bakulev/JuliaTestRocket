var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#PointController.run_point_controller","page":"API Reference","title":"PointController.run_point_controller","text":"run_point_controller()\n\nMain entry point for the Point Controller application. Creates an interactive window with a controllable point using WASD keys.\n\nPrerequisites\n\nA Makie backend must be activated before calling this function:\n\n# For interactive use\nusing GLMakie\nGLMakie.activate!()\n\n# For headless use\nusing CairoMakie\nCairoMakie.activate!()\n\nusing PointController\nrun_point_controller()\n\nFeatures\n\nInteractive point control with WASD keys\nReal-time coordinate display\nComprehensive error handling and robustness\nModern Makie integration following best practices\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.PointController","page":"API Reference","title":"PointController.PointController","text":"PointController.jl\n\nAn interactive Julia application for controlling a point using WASD keyboard inputs with real-time Makie visualization. This module provides a complete implementation of an event-driven point controller with smooth movement, error handling, and performance optimizations.\n\nMain Components\n\nMovement State Management: Tracks key presses and point position\nInput Handling: Processes keyboard events with validation\nVisualization: Makie-based rendering with real-time updates\nError Handling: Comprehensive error recovery and user feedback\n\nUsage\n\n# First, activate a Makie backend (GLMakie for interactive, CairoMakie for headless)\nusing GLMakie\nGLMakie.activate!()\n\n# Then use PointController\nusing PointController\nrun_point_controller()  # Start the interactive application\n\nBackend Activation\n\nPointController requires a Makie backend to be activated before use. This follows modern Makie.jl  patterns where users control backend activation:\n\n# For interactive use (requires display)\nusing GLMakie\nGLMakie.activate!()\n\n# For headless/CI use (no display required)\nusing CairoMakie\nCairoMakie.activate!()\n\n# Then use PointController\nusing PointController\nrun_point_controller()\n\nYou can also customize the backend with options:\n\nGLMakie.activate!(\n    title = \"My Point Controller\",\n    vsync = true,\n    framerate = 60.0\n)\n\nArchitecture\n\nThe application follows a modular, event-driven architecture:\n\nMakie provides the windowing and rendering system\nObservable patterns handle real-time coordinate updates\nMain loop-based movement ensures smooth animation\nComprehensive error handling provides robustness\n\nAuthor: Point Controller Development Team\n\nVersion: 0.1.0\n\nLicense: MIT\n\n\n\n\n\n","category":"module"},{"location":"api/#Core-Functions","page":"API Reference","title":"Core Functions","text":"","category":"section"},{"location":"api/#PointController.setup_visualization_window","page":"API Reference","title":"PointController.setup_visualization_window","text":"setup_visualization_window(fig)\n\nSet up and display the Makie window with proper configuration and performance optimizations.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.setup_keyboard_events!","page":"API Reference","title":"PointController.setup_keyboard_events!","text":"setup_keyboard_events!(fig, state::MovementState, position::Observable{Point2f}, time_obs::Union{Observable{String}, Nothing} = nothing)\n\nSet up keyboard event handlers for the Makie figure with comprehensive error handling. Connects key press and release events to the movement state management system. Includes performance optimizations and robust error recovery.\n\nNote: This function requires a Makie backend to be activated and will only work when called from a context where Makie types are available.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.setup_logging","page":"API Reference","title":"PointController.setup_logging","text":"setup_logging(level::LogLevel = Logging.Info; show_timestamp::Bool = true)\n\nConfigure the global logger for PointController with the specified log level.\n\nArguments\n\nlevel::LogLevel: Minimum log level to display (default: Info)\nshow_timestamp::Bool: Whether to include timestamps in log messages (default: true)\n\nExamples\n\n# Set up info-level logging (default)\nsetup_logging()\n\n# Set up debug-level logging for development\nsetup_logging(Logging.Debug)\n\n# Set up warning-level logging for production\nsetup_logging(Logging.Warn, show_timestamp=false)\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.log_application_start","page":"API Reference","title":"PointController.log_application_start","text":"log_application_start()\n\nLog application startup information.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.log_application_stop","page":"API Reference","title":"PointController.log_application_stop","text":"log_application_stop()\n\nLog application shutdown information.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.log_glmakie_activation","page":"API Reference","title":"PointController.log_glmakie_activation","text":"log_glmakie_activation()\n\nLog GLMakie backend activation status.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.log_component_initialization","page":"API Reference","title":"PointController.log_component_initialization","text":"log_component_initialization(component::String)\n\nLog component initialization.\n\nArguments\n\ncomponent::String: Name of the component being initialized\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.log_user_action","page":"API Reference","title":"PointController.log_user_action","text":"log_user_action(action::String, details::String = \"\")\n\nLog user actions like key presses.\n\nArguments\n\naction::String: Description of the user action\ndetails::String: Additional details about the action (optional)\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.log_error_with_context","page":"API Reference","title":"PointController.log_error_with_context","text":"log_error_with_context(error_msg::String, context::String = \"\", exception = nothing)\n\nLog errors with context information.\n\nArguments\n\nerror_msg::String: Main error message\ncontext::String: Context where the error occurred (optional)\nexception: Exception object for additional details (optional)\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.log_warning_with_context","page":"API Reference","title":"PointController.log_warning_with_context","text":"log_warning_with_context(warning_msg::String, context::String = \"\")\n\nLog warnings with context information.\n\nArguments\n\nwarning_msg::String: Main warning message\ncontext::String: Context where the warning occurred (optional)\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.get_current_log_level","page":"API Reference","title":"PointController.get_current_log_level","text":"get_current_log_level()\n\nGet the current global log level.\n\nReturns\n\nLogLevel: Current minimum log level being displayed\n\n\n\n\n\n","category":"function"},{"location":"api/#Movement-State","page":"API Reference","title":"Movement State","text":"","category":"section"},{"location":"api/#PointController.MovementState","page":"API Reference","title":"PointController.MovementState","text":"MovementState\n\nRepresents the current state of movement and input for the Point Controller.\n\nFields\n\npressed_keys::Set{Char}: Set of currently pressed keys\nmovement_speed::Float64: Movement speed in units per second\nshould_quit::Bool: Flag indicating if the application should quit\nlast_update_time::Float64: Timestamp of the last movement update\nelapsed_time::Float64: Time elapsed since last update in seconds\n\n\n\n\n\n","category":"type"},{"location":"api/#PointController.add_key!","page":"API Reference","title":"PointController.add_key!","text":"add_key!(state::MovementState, key::Char)\n\nAdd a key to the set of pressed keys.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.remove_key!","page":"API Reference","title":"PointController.remove_key!","text":"remove_key!(state::MovementState, key::Char)\n\nRemove a key from the set of pressed keys.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.calculate_movement_vector","page":"API Reference","title":"PointController.calculate_movement_vector","text":"calculate_movement_vector(state::MovementState)\n\nCalculate the movement vector based on currently pressed keys. Returns a normalized 2D vector representing the movement direction and magnitude.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.reset_movement_state!","page":"API Reference","title":"PointController.reset_movement_state!","text":"reset_movement_state!(state::MovementState)\n\nReset the movement state to initial values.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.request_quit!","page":"API Reference","title":"PointController.request_quit!","text":"request_quit!(state::MovementState)\n\nRequest the application to quit.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.get_pressed_keys","page":"API Reference","title":"PointController.get_pressed_keys","text":"get_pressed_keys(state::MovementState)\n\nGet a copy of the currently pressed keys. Returns a Set{Char} containing all currently pressed movement keys.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.update_movement_timing!","page":"API Reference","title":"PointController.update_movement_timing!","text":"update_movement_timing!(state::MovementState, current_time::Float64)\n\nUpdate the movement timing information. Calculates the elapsed time since the last update and stores it in the state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Input-Handling","page":"API Reference","title":"Input Handling","text":"","category":"section"},{"location":"api/#PointController.handle_key_press","page":"API Reference","title":"PointController.handle_key_press","text":"handle_key_press(key::Char, state::MovementState)\n\nProcess a key press event and update the movement state with error handling. Adds the key to the pressed keys set if it's a valid WASD key. Handles quit request if 'q' key is pressed. Gracefully handles invalid key inputs.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.handle_key_release","page":"API Reference","title":"PointController.handle_key_release","text":"handle_key_release(key::Char, state::MovementState)\n\nProcess a key release event and update the movement state with error handling. Removes the key from the pressed keys set if it's a valid WASD key. Gracefully handles invalid key inputs.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.is_movement_key","page":"API Reference","title":"PointController.is_movement_key","text":"is_movement_key(key::Char)\n\nCheck if a key is a valid movement key (WASD). Returns true if the key is in the KEY_MAPPINGS dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.clear_all_keys_safely!","page":"API Reference","title":"PointController.clear_all_keys_safely!","text":"clear_all_keys_safely!(state::MovementState)\n\nSafely clear all pressed keys with error handling.\n\n\n\n\n\n","category":"function"},{"location":"api/#Visualization","page":"API Reference","title":"Visualization","text":"","category":"section"},{"location":"api/#PointController.create_visualization","page":"API Reference","title":"PointController.create_visualization","text":"create_visualization()\n\nCreate and configure the Makie visualization window with point and coordinate display. Includes performance optimizations and error handling. Returns the figure, axis, point observable, coordinate text observable, and time observable.\n\nNote: This function requires a Makie backend to be activated before calling.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.create_point_position","page":"API Reference","title":"PointController.create_point_position","text":"create_point_position()\n\nCreate an observable point position using Makie's Observable type. Returns an Observable containing a Point2f at the origin (0, 0).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.get_current_position","page":"API Reference","title":"PointController.get_current_position","text":"get_current_position(position::Observable{Point2f})\n\nGet the current position as a tuple of coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.update_position_from_state!","page":"API Reference","title":"PointController.update_position_from_state!","text":"update_position_from_state!(position::Observable{Point2f}, state::MovementState)\n\nUpdate position from movement state (alias for applymovementto_position!).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.apply_movement_to_position!","page":"API Reference","title":"PointController.apply_movement_to_position!","text":"apply_movement_to_position!(position::Observable{Point2f}, state::MovementState)\n\nApply movement to the current position based on the movement state. Updates the position observable with the new coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.update_coordinate_display!","page":"API Reference","title":"PointController.update_coordinate_display!","text":"update_coordinate_display!(position::Observable{Point2f})\n\nForce update of coordinate display (useful for manual refresh).\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.update_time_display!","page":"API Reference","title":"PointController.update_time_display!","text":"update_time_display!(time_obs::Observable{String})\n\nUpdate the time display observable.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.create_time_observable","page":"API Reference","title":"PointController.create_time_observable","text":"create_time_observable()\n\nCreate an observable that displays the current time. Returns an Observable containing a formatted time string. Note: Time updates are handled by the main application loop.\n\n\n\n\n\n","category":"function"},{"location":"api/#PointController.format_current_time","page":"API Reference","title":"PointController.format_current_time","text":"format_current_time()\n\nFormat the current time as a string.\n\n\n\n\n\n","category":"function"},{"location":"api/#Constants","page":"API Reference","title":"Constants","text":"","category":"section"},{"location":"api/#PointController.KEY_MAPPINGS","page":"API Reference","title":"PointController.KEY_MAPPINGS","text":"KEY_MAPPINGS\n\nA dictionary mapping keyboard keys to their corresponding movement vectors. Each key maps to a 2-element array representing [x, y] movement direction.\n\nKey Mappings\n\n'w' or 'W': Move up [0, 1]\n's' or 'S': Move down [0, -1]  \n'a' or 'A': Move left [-1, 0]\n'd' or 'D': Move right [1, 0]\n\nUsage\n\n# Check if a key is a movement key\nif haskey(KEY_MAPPINGS, key)\n    movement = KEY_MAPPINGS[key]\nend\n\n\n\n\n\n","category":"constant"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Julia 1.10 or higher\nFor interactive graphics: OpenGL 3.3+ compatible graphics card and drivers\nFor headless operation: No graphics hardware required","category":"page"},{"location":"getting-started/#Setup-Instructions","page":"Getting Started","title":"Setup Instructions","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Install Julia: Download from julialang.org\nClone the repository:\ngit clone https://github.com/bakulev/JuliaTestRocket.git\ncd JuliaTestRocket\nActivate the project environment:\nusing Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"},{"location":"getting-started/#Backend-Activation","page":"Getting Started","title":"Backend Activation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"PointController follows modern Makie.jl patterns where users control backend activation. You must activate a Makie backend before using PointController functions.","category":"page"},{"location":"getting-started/#Available-Backends","page":"Getting Started","title":"Available Backends","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"GLMakie (Interactive Graphics):","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using GLMakie\nGLMakie.activate!()","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Best for: Interactive applications, real-time graphics\nFeatures: Full OpenGL acceleration, interactive windows\nRequirements: OpenGL 3.3+, display system","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"CairoMakie (Static/Headless Graphics):","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using CairoMakie\nCairoMakie.activate!()","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Best for: Publication-quality plots, CI environments, headless operation\nFeatures: Vector graphics, no display required\nRequirements: None (works in headless environments)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"WGLMakie (Web Graphics):","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using WGLMakie\nWGLMakie.activate!()","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Best for: Web applications, browser-based graphics\nFeatures: WebGL-based, runs in browsers\nRequirements: WebGL-capable browser","category":"page"},{"location":"getting-started/#Configuration-Options","page":"Getting Started","title":"Configuration Options","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# Basic activation\nGLMakie.activate!()\n\n# With custom window settings\nGLMakie.activate!(\n    title = \"My Point Controller\",\n    vsync = true,\n    framerate = 60.0,\n    fxaa = true\n)\n\n# For HiDPI displays\nGLMakie.activate!(scalefactor = 2.0)","category":"page"},{"location":"getting-started/#First-Run","page":"Getting Started","title":"First Run","text":"","category":"section"},{"location":"getting-started/#Interactive-Mode-(Recommended)","page":"Getting Started","title":"Interactive Mode (Recommended)","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# Start interactive session\njulia --project=. -i start_interactive.jl\n\n# Then in the Julia REPL, activate your preferred backend:\nusing GLMakie; GLMakie.activate!()\nrun_point_controller()","category":"page"},{"location":"getting-started/#Direct-Execution","page":"Getting Started","title":"Direct Execution","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# Run with GLMakie (interactive)\njulia run_glmakie.jl\n\n# Run with CairoMakie (headless)\njulia run_cairomakie.jl","category":"page"},{"location":"getting-started/#Manual-Setup","page":"Getting Started","title":"Manual Setup","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"# First, activate your preferred Makie backend\nusing GLMakie  # or CairoMakie, WGLMakie\nGLMakie.activate!()\n\n# Then use PointController\nusing PointController\nrun_point_controller()","category":"page"},{"location":"getting-started/#Controls","page":"Getting Started","title":"Controls","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Key Action\nW Move point up (positive Y direction)\nS Move point down (negative Y direction)\nA Move point left (negative X direction)\nD Move point right (positive X direction)\nQ Quit application","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Advanced Controls:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Multiple keys: Press multiple WASD keys simultaneously for diagonal movement\nWindow close: Close the window to exit the application\nFocus handling: Application safely handles window focus changes","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Basic-Usage","page":"Examples","title":"Basic Usage","text":"","category":"section"},{"location":"examples/#Simple-Point-Control","page":"Examples","title":"Simple Point Control","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using GLMakie\nGLMakie.activate!()\nusing PointController\n\n# Start the application\nrun_point_controller()","category":"page"},{"location":"examples/#Custom-Movement-Speed","page":"Examples","title":"Custom Movement Speed","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using GLMakie\nGLMakie.activate!()\nusing PointController\n\n# Create a movement state with custom speed\nstate = MovementState(movement_speed = 0.05)  # Slower movement\n\n# You can also create faster movement\nfast_state = MovementState(movement_speed = 0.2)  # Faster movement","category":"page"},{"location":"examples/#Programmatic-Key-Handling","page":"Examples","title":"Programmatic Key Handling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PointController\n\n# Create a movement state\nstate = MovementState()\n\n# Add keys programmatically\nadd_key!(state, 'w')\nadd_key!(state, 'd')\n\n# Calculate movement vector\nmovement = calculate_movement_vector(state)\nprintln(\"Movement vector: $movement\")\n\n# Remove keys\nremove_key!(state, 'w')\nremove_key!(state, 'd')","category":"page"},{"location":"examples/#Advanced-Usage","page":"Examples","title":"Advanced Usage","text":"","category":"section"},{"location":"examples/#Custom-Backend-Configuration","page":"Examples","title":"Custom Backend Configuration","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using GLMakie\n\n# Configure GLMakie for high-performance rendering\nGLMakie.activate!(\n    title = \"High Performance Point Controller\",\n    vsync = false,           # Disable vsync for maximum FPS\n    framerate = 120.0,       # Target 120 FPS\n    fxaa = true,            # Enable anti-aliasing\n    ssao = false,           # Disable ambient occlusion for performance\n    render_on_demand = false # Continuous rendering\n)\n\nusing PointController\nrun_point_controller()","category":"page"},{"location":"examples/#Development-and-Testing","page":"Examples","title":"Development and Testing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using GLMakie\nGLMakie.activate!(\n    debugging = true,        # Enable debugging\n    visible = true,         # Ensure window is visible\n    vsync = false          # Disable for faster testing\n)\n\nusing PointController\n\n# Test individual components\nstate = MovementState(movement_speed = 1.0)\n@assert is_movement_key('w') == true\n@assert is_movement_key('x') == false\n\n# Test movement calculations\nadd_key!(state, 'w')\nadd_key!(state, 'd')\nmovement = calculate_movement_vector(state)\n@assert movement ≈ [0.7071, 0.7071] atol=0.001  # Normalized diagonal","category":"page"},{"location":"examples/#Integration-Examples","page":"Examples","title":"Integration Examples","text":"","category":"section"},{"location":"examples/#Using-with-Other-Packages","page":"Examples","title":"Using with Other Packages","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using GLMakie\nGLMakie.activate!()\nusing PointController\nusing Plots  # For additional plotting\n\n# You can use PointController alongside other visualization packages\n# Just make sure GLMakie is activated first\n\n# Run the point controller\nrun_point_controller()\n\n# After closing, you can use other plotting packages\n# (Note: You may need to switch backends for other packages)","category":"page"},{"location":"examples/#Batch-Processing","page":"Examples","title":"Batch Processing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using GLMakie\nGLMakie.activate!()\nusing PointController\n\n# Function to run multiple sessions\nfunction run_multiple_sessions(n_sessions::Int)\n    for i in 1:n_sessions\n        println(\"Starting session $i of $n_sessions\")\n        run_point_controller()\n        println(\"Session $i completed\")\n    end\nend\n\n# Run 3 sessions\nrun_multiple_sessions(3)","category":"page"},{"location":"architecture/#PointController-Architecture","page":"Architecture","title":"PointController Architecture","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"This document describes the core architectural patterns and design principles used in the PointController application, focusing on visualization and input processing systems.","category":"page"},{"location":"architecture/#Table-of-Contents","page":"Architecture","title":"Table of Contents","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Overview\nVisualization Architecture\nInput Processing Architecture\nObservable System\nEvent Flow\nPerformance Considerations\nError Handling","category":"page"},{"location":"architecture/#Overview","page":"Architecture","title":"Overview","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"PointController follows a reactive, event-driven architecture built on top of Makie's Observable system. The application is designed with clear separation of concerns, robust error handling, and performance optimizations.","category":"page"},{"location":"architecture/#Key-Architectural-Principles","page":"Architecture","title":"Key Architectural Principles","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Reactive Programming: Uses Makie's Observable system for automatic UI updates\nEvent-Driven: Asynchronous event processing, not polling\nSeparation of Concerns: Each module handles a specific aspect\nState-Based: Movement calculated from current state, not individual events\nError Recovery: Graceful handling of failures at each layer","category":"page"},{"location":"architecture/#Visualization-Architecture","page":"Architecture","title":"Visualization Architecture","text":"","category":"section"},{"location":"architecture/#Core-Components","page":"Architecture","title":"Core Components","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"The visualization system is built around Makie's Observable pattern with the following components:","category":"page"},{"location":"architecture/#1.-Observable-Position-Management","page":"Architecture","title":"1. Observable Position Management","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Create observable point position\npoint_position = Observable(Point2f(0, 0))\n\n# Visual elements automatically update when position changes\nMain.scatter!(ax, point_position,\n    color = :red,\n    markersize = 20,\n    marker = :circle,\n    strokewidth = 0,\n)","category":"page"},{"location":"architecture/#2.-Reactive-Text-Display","page":"Architecture","title":"2. Reactive Text Display","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Coordinate text that updates automatically\ncoordinate_text = Main.lift(point_position) do pos\n    x_rounded = round(pos[1], digits = 2)\n    y_rounded = round(pos[2], digits = 2)\n    return \"Position: ($x_rounded, $y_rounded)\"\nend\n\n# Time display\ntime_text = Main.lift(current_time_obs) do time_val\n    return \"Time: $time_val\"\nend","category":"page"},{"location":"architecture/#3.-Visual-Layout","page":"Architecture","title":"3. Visual Layout","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Create figure with optimized configuration\nfig = Main.Figure(\n    size = (800, 600),\n    title = \"Point Controller\",\n    figure_padding = 10,\n    fontsize = 12,\n)\n\n# Create axis with coordinate system\nax = Main.Axis(fig[1, 1],\n    xlabel = \"X Coordinate\",\n    ylabel = \"Y Coordinate\",\n    title = \"Interactive Point Control (Use WASD keys)\",\n    aspect = Main.DataAspect(),\n    limits = (-10, 10, -10, 10),\n)","category":"page"},{"location":"architecture/#How-Visualization-Updates-Work","page":"Architecture","title":"How Visualization Updates Work","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Position Change: point_position[] = new_value\nObservable Trigger: All connected visual elements are notified\nAutomatic Re-render: Makie automatically updates the display\nNo Manual Refresh: No explicit display calls needed","category":"page"},{"location":"architecture/#Performance-Optimizations","page":"Architecture","title":"Performance Optimizations","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Render on Demand: Only redraws when Observables change\nEfficient Markers: Optimized point rendering without overdraw\nMinimal Grid: Simplified grid system for better performance\nFrame Rate Control: 60 FPS update frequency for smooth animation","category":"page"},{"location":"architecture/#Input-Processing-Architecture","page":"Architecture","title":"Input Processing Architecture","text":"","category":"section"},{"location":"architecture/#4-Layer-Event-Processing-System","page":"Architecture","title":"4-Layer Event Processing System","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"The input processing follows a layered architecture that separates concerns and provides robust error handling.","category":"page"},{"location":"architecture/#Layer-1:-Event-Capture-(Makie-Backend)","page":"Architecture","title":"Layer 1: Event Capture (Makie Backend)","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Makie captures raw keyboard events from the OS\nMain.on(Main.events(fig).keyboardbutton) do event\n    key_string = string(event.key)\n    key_char = first(key_string)\n    \n    if event.action == Main.Keyboard.press\n        handle_key_press(key_char, state)\n    elseif event.action == Main.Keyboard.release\n        handle_key_release(key_char, state)\n    end\nend","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Responsibilities:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Capture raw keyboard events from the operating system\nConvert events to structured format with key and action\nTrigger callback functions for each event","category":"page"},{"location":"architecture/#Layer-2:-Event-Processing-(Input-Handler)","page":"Architecture","title":"Layer 2: Event Processing (Input Handler)","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"function handle_key_press(key::Char, state::MovementState)\n    # Handle quit key\n    if lowercase(key) == 'q'\n        request_quit!(state)\n        return state\n    end\n\n    # Only process WASD keys for movement\n    if haskey(KEY_MAPPINGS, key)\n        add_key!(state, key)\n        log_user_action(\"Key pressed\", string(key))\n    else\n        # Silently ignore non-movement keys\n        @debug \"Ignored key: $key\"\n    end\nend","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Responsibilities:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Validate and filter keyboard input\nHandle special keys (quit, movement keys)\nUpdate movement state\nLog user actions for debugging\nGracefully handle invalid inputs","category":"page"},{"location":"architecture/#Layer-3:-State-Management-(Movement-State)","page":"Architecture","title":"Layer 3: State Management (Movement State)","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Key mappings for movement\nconst KEY_MAPPINGS = Dict(\n    'w' => [0, 1],    # Up\n    's' => [0, -1],   # Down\n    'a' => [-1, 0],   # Left\n    'd' => [1, 0],    # Right\n    'W' => [0, 1],    # Up (shift)\n    'S' => [0, -1],   # Down (shift)\n    'A' => [-1, 0],   # Left (shift)\n    'D' => [1, 0],    # Right (shift)\n)\n\nfunction calculate_movement_vector(state::MovementState)\n    if isempty(state.pressed_keys)\n        return [0.0, 0.0]\n    end\n\n    # Calculate total movement vector from all pressed keys\n    total_movement = [0.0, 0.0]\n    for key in state.pressed_keys\n        if haskey(KEY_MAPPINGS, key)\n            movement = KEY_MAPPINGS[key]\n            total_movement[1] += movement[1]\n            total_movement[2] += movement[2]\n        end\n    end\n\n    # Normalize for consistent speed\n    magnitude = sqrt(total_movement[1]^2 + total_movement[2]^2)\n    if magnitude > 0\n        return [total_movement[1] / magnitude, total_movement[2] / magnitude]\n    else\n        return [0.0, 0.0]\n    end\nend","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Responsibilities:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Maintain set of currently pressed keys\nMap keys to movement vectors\nCalculate combined movement from multiple keys\nNormalize diagonal movement for consistent speed\nHandle movement timing and speed control","category":"page"},{"location":"architecture/#Layer-4:-Application-Loop-(Main-Loop)","page":"Architecture","title":"Layer 4: Application Loop (Main Loop)","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Main application loop at 60 FPS\nwhile Main.events(fig).window_open[] && !movement_state.should_quit\n    current_time = time()\n    \n    if current_time - last_update_time >= update_interval  # 60 FPS\n        # Update time display\n        time_obs[] = format_current_time()\n        \n        # Update timing\n        update_movement_timing!(movement_state, current_time)\n        \n        # Update position based on current key states\n        apply_movement_to_position!(point_position, movement_state)\n        \n        @debug \"Main loop update: position = $(point_position[]), keys = $(movement_state.pressed_keys)\"\n    end\n    \n    sleep(0.1)  # Small sleep to prevent busy waiting\nend","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Responsibilities:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Run at consistent 60 FPS for smooth movement\nRead current state of pressed keys\nApply movement calculations to position\nUpdate Observables to trigger visual changes\nHandle application lifecycle (quit, window close)","category":"page"},{"location":"architecture/#Observable-System","page":"Architecture","title":"Observable System","text":"","category":"section"},{"location":"architecture/#What-are-Observables?","page":"Architecture","title":"What are Observables?","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Observables are reactive variables that automatically trigger updates when their values change. They form the backbone of the reactive visualization system.","category":"page"},{"location":"architecture/#Observable-Patterns-in-PointController","page":"Architecture","title":"Observable Patterns in PointController","text":"","category":"section"},{"location":"architecture/#1.-Observable-Creation","page":"Architecture","title":"1. Observable Creation","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Create observable with initial value\npoint_position = Observable(Point2f(0, 0))\ntime_obs = Observable(format_current_time())","category":"page"},{"location":"architecture/#2.-Observable-Access","page":"Architecture","title":"2. Observable Access","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Reading from Observable\ncurrent_pos = point_position[]                    # Get current value\n@debug \"position = $(point_position[])\"           # Access in debug\n\n# Writing to Observable\nposition[] = Point2f(new_x, new_y)               # Set new value\ntime_obs[] = format_current_time()               # Update time","category":"page"},{"location":"architecture/#3.-Observable-Connection","page":"Architecture","title":"3. Observable Connection","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Connect Observable to visual element\nMain.scatter!(ax, point_position, ...)           # Point follows Observable\n\n# Create reactive text that updates with Observable\ncoordinate_text = Main.lift(point_position) do pos\n    return \"Position: ($(pos[1]), $(pos[2]))\"\nend","category":"page"},{"location":"architecture/#How-to-Identify-Observables","page":"Architecture","title":"How to Identify Observables","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Pattern Observable Regular Variable\nCreation obs = Observable(value) var = value\nReading value = obs[] value = var\nWriting obs[] = new_value var = new_value\nType Observable{T} T\nBehavior Triggers updates when changed No automatic updates","category":"page"},{"location":"architecture/#Event-Flow","page":"Architecture","title":"Event Flow","text":"","category":"section"},{"location":"architecture/#Complete-Input-to-Display-Flow","page":"Architecture","title":"Complete Input-to-Display Flow","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"User presses 'W' key\n        ↓\n┌─────────────────────────────────────┐\n│ 1. OS → Makie Backend (GLMakie)     │ ← Raw keyboard event capture\n│    event.key = :w, action = :press  │\n└─────────────────────────────────────┘\n        ↓\n┌─────────────────────────────────────┐\n│ 2. Input Handler                    │ ← Event validation & processing\n│    handle_key_press('w', state)     │\n│    → add_key!(state, 'w')           │\n└─────────────────────────────────────┘\n        ↓\n┌─────────────────────────────────────┐\n│ 3. Movement State                   │ ← State management\n│    state.pressed_keys = Set(['w'])  │\n│    calculate_movement_vector()      │\n│    → [0.0, 1.0] (upward vector)    │\n└─────────────────────────────────────┘\n        ↓\n┌─────────────────────────────────────┐\n│ 4. Main Loop (60 FPS)              │ ← Application loop\n│    apply_movement_to_position!()    │\n│    → point_position[] = new_pos     │\n└─────────────────────────────────────┘\n        ↓\n┌─────────────────────────────────────┐\n│ 5. Observable System                │ ← Reactive updates\n│    point_position[] triggers        │\n│    → scatter plot updates           │\n│    → coordinate text updates        │\n└─────────────────────────────────────┘\n        ↓\n┌─────────────────────────────────────┐\n│ 6. Display                          │ ← Visual rendering\n│    Red point moves upward           │\n│    Coordinates show new position    │\n└─────────────────────────────────────┘","category":"page"},{"location":"architecture/#Key-Benefits-of-This-Flow","page":"Architecture","title":"Key Benefits of This Flow","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Asynchronous: Input processing doesn't block visualization\nState-Based: Movement calculated from current state, not individual events\nReactive: Display updates automatically when state changes\nEfficient: Only updates when necessary, not every frame\nRobust: Error handling at each layer","category":"page"},{"location":"architecture/#Performance-Considerations","page":"Architecture","title":"Performance Considerations","text":"","category":"section"},{"location":"architecture/#Optimization-Strategies","page":"Architecture","title":"Optimization Strategies","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Render on Demand: Only redraw when Observables change\nEfficient State Management: Use Set for pressed keys (O(1) operations)\nFrame Rate Control: 60 FPS main loop for smooth animation\nMinimal Allocations: Reuse objects where possible\nLazy Updates: Update timing only when needed","category":"page"},{"location":"architecture/#Memory-Management","page":"Architecture","title":"Memory Management","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Observable Cleanup: Makie handles Observable lifecycle\nState Reset: Clear pressed keys when window loses focus\nError Recovery: Graceful cleanup on failures","category":"page"},{"location":"architecture/#Error-Handling","page":"Architecture","title":"Error Handling","text":"","category":"section"},{"location":"architecture/#Multi-Layer-Error-Recovery","page":"Architecture","title":"Multi-Layer Error Recovery","text":"","category":"section"},{"location":"architecture/#1.-Input-Layer-Errors","page":"Architecture","title":"1. Input Layer Errors","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"function handle_key_press(key::Char, state::MovementState)\n    try\n        # Process key press\n        if haskey(KEY_MAPPINGS, key)\n            add_key!(state, key)\n        end\n    catch e\n        @warn \"Error processing key press\" exception=string(e)\n        return state  # Return unchanged state\n    end\nend","category":"page"},{"location":"architecture/#2.-State-Management-Errors","page":"Architecture","title":"2. State Management Errors","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"function apply_movement_to_position!(position::Observable{Point2f}, state::MovementState)\n    try\n        # Calculate and apply movement\n        position[] = new_position\n    catch e\n        @error \"Error applying movement\" exception=string(e)\n        # Position remains unchanged\n    end\nend","category":"page"},{"location":"architecture/#3.-Visualization-Errors","page":"Architecture","title":"3. Visualization Errors","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"coordinate_text = Main.lift(point_position) do pos\n    try\n        return \"Position: ($(pos[1]), $(pos[2]))\"\n    catch e\n        @warn \"Error updating coordinate text\" exception=string(e)\n        return \"Position: (Error, Error)\"\n    end\nend","category":"page"},{"location":"architecture/#Error-Recovery-Strategies","page":"Architecture","title":"Error Recovery Strategies","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Graceful Degradation: Continue operation with reduced functionality\nState Preservation: Don't corrupt state on errors\nUser Feedback: Log errors for debugging\nAutomatic Recovery: Clear stuck states (e.g., keys on focus loss)","category":"page"},{"location":"architecture/#Conclusion","page":"Architecture","title":"Conclusion","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"The PointController architecture demonstrates modern reactive programming patterns with:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Clear separation of concerns across multiple layers\nReactive visualization using Makie's Observable system\nRobust input processing with comprehensive error handling\nPerformance optimizations for smooth real-time interaction\nMaintainable code structure with well-defined interfaces","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"This architecture provides a solid foundation for interactive applications that require real-time input processing and responsive visualization.","category":"page"},{"location":"architecture/#Advanced-Architecture-Patterns","page":"Architecture","title":"Advanced Architecture Patterns","text":"","category":"section"},{"location":"architecture/#Makie-Separation-and-Portability","page":"Architecture","title":"Makie Separation and Portability","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"The current architecture can be refactored to separate Makie-specific code from core simulation logic, enabling use with other visualization systems like Pluto, PlutoUI, or Plots.","category":"page"},{"location":"architecture/#Proposed-Architecture-Layers","page":"Architecture","title":"Proposed Architecture Layers","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"┌─────────────────────────────────────────────────────────────┐\n│                    Application Layer                        │\n│  (Pluto, Jupyter, Standalone, etc.)                        │\n└─────────────────────────────────────────────────────────────┘\n                              │\n┌─────────────────────────────────────────────────────────────┐\n│                  Visualization Adapter                      │\n│  (MakieAdapter, PlutoAdapter, PlotsAdapter)                │\n└─────────────────────────────────────────────────────────────┘\n                              │\n┌─────────────────────────────────────────────────────────────┐\n│                   Simulation Engine                         │\n│  (StateManager, PhysicsEngine, BayesianEngine)             │\n└─────────────────────────────────────────────────────────────┘\n                              │\n┌─────────────────────────────────────────────────────────────┘\n│                    Core State System                        │\n│  (ObservableState, EventSystem, InputHandler)              │\n└─────────────────────────────────────────────────────────────┘","category":"page"},{"location":"architecture/#Core-State-System-(Makie-Independent)","page":"Architecture","title":"Core State System (Makie-Independent)","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Core state management without Makie dependencies\nmodule CoreState\n\nusing Observables: Observable\nusing Dates\n\nexport SimulationState, StateHistory, PhysicsEngine\nexport update_state!, calculate_next_state, get_current_state\n\n\"\"\"\n    SimulationState\n\nCore simulation state without visualization dependencies.\n\"\"\"\nmutable struct SimulationState\n    position::Observable{Point2f}\n    velocity::Observable{Point2f}\n    time::Observable{Float64}\n    pressed_keys::Observable{Set{Char}}\n    mass::Float64\n    damping::Float64\nend\n\n\"\"\"\n    StateHistory\n\nHistory of states for Bayesian inference and physics calculations.\n\"\"\"\nstruct StateHistory\n    states::Vector{SimulationState}\n    timestamps::Vector{Float64}\n    max_history::Int\nend\n\n\"\"\"\n    PhysicsEngine\n\nHandles physics calculations and state transitions.\n\"\"\"\nstruct PhysicsEngine\n    gravity::Point2f\n    friction::Float64\n    time_step::Float64\nend\n\n# Core functions that work with any visualization system\nfunction update_state!(state::SimulationState, dt::Float64)\n    # Physics calculations\n    # State updates\n    # Observable notifications\nend\n\nfunction calculate_next_state(current::SimulationState, history::StateHistory, engine::PhysicsEngine)\n    # Bayesian inference for parameter estimation\n    # Physics prediction\n    # Return next state\nend\n\nend # module CoreState","category":"page"},{"location":"architecture/#Visualization-Adapter-Pattern","page":"Architecture","title":"Visualization Adapter Pattern","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Abstract visualization interface\nabstract type VisualizationAdapter end\n\n# Makie-specific implementation\nstruct MakieAdapter <: VisualizationAdapter\n    fig::Figure\n    ax::Axis\n    point_plot::Any\n    text_plots::Vector{Any}\nend\n\n# Pluto-specific implementation\nstruct PlutoAdapter <: VisualizationAdapter\n    plot_output::Any\n    text_output::Any\nend\n\n# Plots-specific implementation\nstruct PlotsAdapter <: VisualizationAdapter\n    plot::Any\n    annotations::Vector{Any}\nend\n\n# Common interface\nfunction setup_visualization(adapter::VisualizationAdapter, state::SimulationState)\n    # Setup visualization based on adapter type\nend\n\nfunction update_visualization(adapter::VisualizationAdapter, state::SimulationState)\n    # Update visualization based on adapter type\nend","category":"page"},{"location":"architecture/#Physical-Simulation-with-Bayesian-Extensibility","page":"Architecture","title":"Physical Simulation with Bayesian Extensibility","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"The original vision of demonstrating physical laws with Bayesian inference can be implemented as follows:","category":"page"},{"location":"architecture/#Enhanced-State-System","page":"Architecture","title":"Enhanced State System","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"\"\"\"\n    BayesianSimulationState\n\nExtended state system with Bayesian inference capabilities.\n\"\"\"\nmutable struct BayesianSimulationState\n    # Core state\n    position::Observable{Point2f}\n    velocity::Observable{Point2f}\n    time::Observable{Float64}\n    pressed_keys::Observable{Set{Char}}\n    \n    # Physics parameters (with uncertainty)\n    mass::Observable{Normal{Float64}}  # Bayesian mass estimate\n    damping::Observable{Normal{Float64}}  # Bayesian damping estimate\n    \n    # State history for inference\n    history::StateHistory\n    \n    # Bayesian inference engine\n    inference_engine::BayesianInferenceEngine\nend\n\n\"\"\"\n    BayesianInferenceEngine\n\nHandles Bayesian parameter estimation and prediction.\n\"\"\"\nstruct BayesianInferenceEngine\n    prior_mass::Normal{Float64}\n    prior_damping::Normal{Float64}\n    observation_noise::Float64\n    learning_rate::Float64\nend\n\n\"\"\"\n    StateEvaluationFunction\n\nEvaluates next state using Bayesian inference and physics.\n\"\"\"\nfunction evaluate_next_state(\n    current_state::BayesianSimulationState,\n    dt::Float64,\n    engine::BayesianInferenceEngine\n)\n    # 1. Update Bayesian parameter estimates from history\n    updated_mass = update_mass_estimate(current_state, engine)\n    updated_damping = update_damping_estimate(current_state, engine)\n    \n    # 2. Predict next state using current physics model\n    predicted_position = predict_position(current_state, dt, updated_mass, updated_damping)\n    predicted_velocity = predict_velocity(current_state, dt, updated_mass, updated_damping)\n    \n    # 3. Update state with predictions\n    current_state.position[] = predicted_position\n    current_state.velocity[] = predicted_velocity\n    current_state.time[] += dt\n    current_state.mass[] = updated_mass\n    current_state.damping[] = updated_damping\n    \n    # 4. Add to history for future inference\n    add_to_history!(current_state.history, current_state)\n    \n    return current_state\nend","category":"page"},{"location":"architecture/#Physics-Integration","page":"Architecture","title":"Physics Integration","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"\"\"\"\n    PhysicsModel\n\nDefines the physical laws governing the system.\n\"\"\"\nstruct PhysicsModel\n    gravity::Point2f\n    force_field::Function  # Custom force field\n    constraints::Vector{Constraint}\nend\n\n\"\"\"\n    Constraint\n\nPhysical constraints (boundaries, etc.)\n\"\"\"\nabstract type Constraint end\n\nstruct BoundaryConstraint <: Constraint\n    min_bounds::Point2f\n    max_bounds::Point2f\nend\n\n# Physics calculation with Bayesian parameters\nfunction apply_physics(\n    state::BayesianSimulationState,\n    dt::Float64,\n    model::PhysicsModel\n)\n    # Get current parameter estimates\n    mass = mean(state.mass[])\n    damping = mean(state.damping[])\n    \n    # Calculate forces\n    gravity_force = mass * model.gravity\n    damping_force = -damping * state.velocity[]\n    custom_force = model.force_field(state.position[], state.velocity[])\n    \n    total_force = gravity_force + damping_force + custom_force\n    \n    # Update velocity (F = ma)\n    acceleration = total_force / mass\n    new_velocity = state.velocity[] + acceleration * dt\n    \n    # Update position\n    new_position = state.position[] + new_velocity * dt\n    \n    # Apply constraints\n    new_position = apply_constraints(new_position, model.constraints)\n    \n    return new_position, new_velocity\nend","category":"page"},{"location":"architecture/#Bayesian-Parameter-Learning","page":"Architecture","title":"Bayesian Parameter Learning","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"\"\"\"\n    update_mass_estimate\n\nUpdate mass estimate using Bayesian inference from state history.\n\"\"\"\nfunction update_mass_estimate(state::BayesianSimulationState, engine::BayesianInferenceEngine)\n    if length(state.history.states) < 2\n        return engine.prior_mass\n    end\n    \n    # Extract observations from history\n    observations = extract_mass_observations(state.history)\n    \n    # Bayesian update\n    posterior = bayesian_update(engine.prior_mass, observations, engine.observation_noise)\n    \n    return posterior\nend\n\n\"\"\"\n    extract_mass_observations\n\nExtract mass-related observations from state history.\n\"\"\"\nfunction extract_mass_observations(history::StateHistory)\n    observations = Float64[]\n    \n    for i in 2:length(history.states)\n        prev_state = history.states[i-1]\n        curr_state = history.states[i]\n        dt = history.timestamps[i] - history.timestamps[i-1]\n        \n        # Calculate observed acceleration\n        velocity_change = curr_state.velocity[] - prev_state.velocity[]\n        observed_acceleration = velocity_change / dt\n        \n        # Calculate applied force\n        applied_force = calculate_applied_force(prev_state)\n        \n        # Estimate mass: F = ma → m = F/a\n        if norm(observed_acceleration) > 1e-6\n            estimated_mass = norm(applied_force) / norm(observed_acceleration)\n            push!(observations, estimated_mass)\n        end\n    end\n    \n    return observations\nend","category":"page"},{"location":"architecture/#Implementation-Strategy","page":"Architecture","title":"Implementation Strategy","text":"","category":"section"},{"location":"architecture/#Phase-1:-Core-State-Separation","page":"Architecture","title":"Phase 1: Core State Separation","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Extract Core State: Move state management to Makie-independent module\nCreate Adapter Interface: Define abstract visualization interface\nImplement Makie Adapter: Refactor current Makie code as adapter\nTest with Mock Adapter: Verify core logic works without Makie","category":"page"},{"location":"architecture/#Phase-2:-Physics-Integration","page":"Architecture","title":"Phase 2: Physics Integration","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Add Physics Engine: Implement basic physics calculations\nExtend State Structure: Add velocity, mass, damping parameters\nImplement State Evaluation: Create state transition function\nAdd History Management: Track state history for inference","category":"page"},{"location":"architecture/#Phase-3:-Bayesian-Extensibility","page":"Architecture","title":"Phase 3: Bayesian Extensibility","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Add Bayesian Parameters: Replace scalar parameters with distributions\nImplement Inference Engine: Add parameter learning from history\nCreate Observation Extraction: Extract physics observations from history\nAdd Prediction Uncertainty: Include uncertainty in state predictions","category":"page"},{"location":"architecture/#Phase-4:-Multi-Platform-Support","page":"Architecture","title":"Phase 4: Multi-Platform Support","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Pluto Adapter: Implement Pluto-specific visualization\nPlots Adapter: Implement Plots.jl visualization\nJupyter Adapter: Implement Jupyter notebook support\nTesting Framework: Test with multiple visualization backends","category":"page"},{"location":"architecture/#Benefits-of-This-Approach","page":"Architecture","title":"Benefits of This Approach","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"Portability: Core simulation works with any visualization system\nTestability: Core logic can be tested without graphics dependencies\nExtensibility: Easy to add new visualization backends\nScientific Rigor: Proper physics simulation with uncertainty quantification\nEducational Value: Demonstrates Bayesian inference in physical systems\nReactive Architecture: Preserves Observable benefits across all platforms","category":"page"},{"location":"architecture/#Example-Usage","page":"Architecture","title":"Example Usage","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"# Core simulation (works anywhere)\nusing CoreState\nstate = create_simulation_state()\nengine = create_physics_engine()\n\n# Makie visualization\nusing MakieAdapter\nmakie_adapter = MakieAdapter(fig, ax, point_plot, text_plots)\nsetup_visualization(makie_adapter, state)\n\n# Pluto visualization\nusing PlutoAdapter\npluto_adapter = PlutoAdapter(plot_output, text_output)\nsetup_visualization(pluto_adapter, state)\n\n# Same core logic, different visualization\nwhile simulation_running\n    evaluate_next_state!(state, dt, engine)\n    update_visualization(adapter, state)\nend","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"This architecture maintains the reactive benefits while providing the flexibility and scientific rigor you're looking for.","category":"page"},{"location":"refactoring_plan/#Refactoring-Plan:-From-Current-to-Advanced-Architecture","page":"Refactoring Plan","title":"Refactoring Plan: From Current to Advanced Architecture","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"This document provides a step-by-step plan to refactor the current PointController into the advanced architecture with Makie separation and Bayesian physics simulation.","category":"page"},{"location":"refactoring_plan/#Current-State-Analysis","page":"Refactoring Plan","title":"Current State Analysis","text":"","category":"section"},{"location":"refactoring_plan/#Current-Architecture","page":"Refactoring Plan","title":"Current Architecture","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"PointController.jl (Main module)\n├── movement_state.jl (State management)\n├── input_handler.jl (Event processing)\n├── visualization.jl (Makie-specific)\n└── logging_config.jl (Utilities)","category":"page"},{"location":"refactoring_plan/#Current-Dependencies","page":"Refactoring Plan","title":"Current Dependencies","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"All modules depend on Makie for visualization\nState management mixed with visualization logic\nNo separation between core simulation and display","category":"page"},{"location":"refactoring_plan/#Phase-1:-Core-State-Separation","page":"Refactoring Plan","title":"Phase 1: Core State Separation","text":"","category":"section"},{"location":"refactoring_plan/#Step-1.1:-Create-Core-State-Module","page":"Refactoring Plan","title":"Step 1.1: Create Core State Module","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"Create src/core_state.jl:","category":"page"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"\"\"\"\n# Core State Module\n\nCore simulation state management without visualization dependencies.\nThis module provides the foundation for the simulation engine.\n\"\"\"\n\nmodule CoreState\n\nusing Observables: Observable\nusing StaticArrays: SVector\nusing Dates\n\n# Type definitions\nconst Point2f = SVector{2, Float32}\n\nexport SimulationState, StateHistory, PhysicsEngine\nexport update_state!, calculate_next_state, get_current_state\nexport create_simulation_state, create_physics_engine\n\n\"\"\"\n    SimulationState\n\nCore simulation state without visualization dependencies.\n\"\"\"\nmutable struct SimulationState\n    position::Observable{Point2f}\n    velocity::Observable{Point2f}\n    time::Observable{Float64}\n    pressed_keys::Observable{Set{Char}}\n    mass::Float64\n    damping::Float64\n    should_quit::Bool\n    \n    function SimulationState(; \n        initial_position::Point2f = Point2f(0, 0),\n        mass::Float64 = 1.0,\n        damping::Float64 = 0.1\n    )\n        return new(\n            Observable(initial_position),\n            Observable(Point2f(0, 0)),\n            Observable(0.0),\n            Observable(Set{Char}()),\n            mass,\n            damping,\n            false\n        )\n    end\nend\n\n\"\"\"\n    StateHistory\n\nHistory of states for Bayesian inference and physics calculations.\n\"\"\"\nmutable struct StateHistory\n    states::Vector{SimulationState}\n    timestamps::Vector{Float64}\n    max_history::Int\n    \n    function StateHistory(max_history::Int = 100)\n        return new(SimulationState[], Float64[], max_history)\n    end\nend\n\n\"\"\"\n    PhysicsEngine\n\nHandles physics calculations and state transitions.\n\"\"\"\nstruct PhysicsEngine\n    gravity::Point2f\n    friction::Float64\n    time_step::Float64\n    bounds::Tuple{Point2f, Point2f}\n    \n    function PhysicsEngine(;\n        gravity::Point2f = Point2f(0, -9.81),\n        friction::Float64 = 0.1,\n        time_step::Float64 = 1/60,\n        bounds::Tuple{Point2f, Point2f} = (Point2f(-10, -10), Point2f(10, 10))\n    )\n        return new(gravity, friction, time_step, bounds)\n    end\nend\n\n# Core state management functions\nfunction add_key!(state::SimulationState, key::Char)\n    keys = state.pressed_keys[]\n    push!(keys, key)\n    state.pressed_keys[] = keys\nend\n\nfunction remove_key!(state::SimulationState, key::Char)\n    keys = state.pressed_keys[]\n    delete!(keys, key)\n    state.pressed_keys[] = keys\nend\n\nfunction clear_keys!(state::SimulationState)\n    state.pressed_keys[] = Set{Char}()\nend\n\nfunction request_quit!(state::SimulationState)\n    state.should_quit = true\nend\n\n# Physics calculations\nfunction calculate_movement_vector(state::SimulationState)\n    keys = state.pressed_keys[]\n    if isempty(keys)\n        return Point2f(0, 0)\n    end\n    \n    # Key mappings (moved from movement_state.jl)\n    const KEY_MAPPINGS = Dict(\n        'w' => Point2f(0, 1),    # Up\n        's' => Point2f(0, -1),   # Down\n        'a' => Point2f(-1, 0),   # Left\n        'd' => Point2f(1, 0),    # Right\n        'W' => Point2f(0, 1),    # Up (shift)\n        'S' => Point2f(0, -1),   # Down (shift)\n        'A' => Point2f(-1, 0),   # Left (shift)\n        'D' => Point2f(1, 0),    # Right (shift)\n    )\n    \n    total_movement = Point2f(0, 0)\n    for key in keys\n        if haskey(KEY_MAPPINGS, key)\n            total_movement += KEY_MAPPINGS[key]\n        end\n    end\n    \n    # Normalize for consistent speed\n    magnitude = sqrt(total_movement[1]^2 + total_movement[2]^2)\n    if magnitude > 0\n        return total_movement / magnitude\n    else\n        return Point2f(0, 0)\n    end\nend\n\nfunction apply_physics!(state::SimulationState, engine::PhysicsEngine, dt::Float64)\n    # Get current state\n    pos = state.position[]\n    vel = state.velocity[]\n    \n    # Calculate input force from pressed keys\n    input_direction = calculate_movement_vector(state)\n    input_force = input_direction * 5.0  # Input force magnitude\n    \n    # Calculate physics forces\n    gravity_force = state.mass * engine.gravity\n    damping_force = -state.damping * vel\n    \n    # Total force\n    total_force = input_force + gravity_force + damping_force\n    \n    # Update velocity (F = ma)\n    acceleration = total_force / state.mass\n    new_velocity = vel + acceleration * dt\n    \n    # Update position\n    new_position = pos + new_velocity * dt\n    \n    # Apply boundary constraints\n    min_bounds, max_bounds = engine.bounds\n    new_position = Point2f(\n        clamp(new_position[1], min_bounds[1], max_bounds[1]),\n        clamp(new_position[2], min_bounds[2], max_bounds[2])\n    )\n    \n    # Update state\n    state.position[] = new_position\n    state.velocity[] = new_velocity\n    state.time[] += dt\n    \n    return state\nend\n\nfunction add_to_history!(history::StateHistory, state::SimulationState)\n    # Create a copy of the current state for history\n    state_copy = SimulationState(\n        position = Observable(state.position[]),\n        velocity = Observable(state.velocity[]),\n        time = Observable(state.time[]),\n        pressed_keys = Observable(copy(state.pressed_keys[])),\n        mass = state.mass,\n        damping = state.damping\n    )\n    \n    push!(history.states, state_copy)\n    push!(history.timestamps, state.time[])\n    \n    # Maintain history size limit\n    if length(history.states) > history.max_history\n        popfirst!(history.states)\n        popfirst!(history.timestamps)\n    end\nend\n\n# Factory functions\nfunction create_simulation_state(; kwargs...)\n    return SimulationState(; kwargs...)\nend\n\nfunction create_physics_engine(; kwargs...)\n    return PhysicsEngine(; kwargs...)\nend\n\nfunction create_state_history(max_history::Int = 100)\n    return StateHistory(max_history)\nend\n\nend # module CoreState","category":"page"},{"location":"refactoring_plan/#Step-1.2:-Create-Visualization-Adapter-Interface","page":"Refactoring Plan","title":"Step 1.2: Create Visualization Adapter Interface","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"Create src/visualization_adapters.jl:","category":"page"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"\"\"\"\n# Visualization Adapters\n\nAbstract interface and implementations for different visualization backends.\n\"\"\"\n\nmodule VisualizationAdapters\n\nusing Observables: Observable\nusing StaticArrays: SVector\n\nconst Point2f = SVector{2, Float32}\n\nexport VisualizationAdapter, setup_visualization, update_visualization\nexport MakieAdapter, create_makie_adapter\n\n\"\"\"\n    VisualizationAdapter\n\nAbstract type for visualization adapters.\n\"\"\"\nabstract type VisualizationAdapter end\n\n\"\"\"\n    setup_visualization(adapter::VisualizationAdapter, state)\n\nSetup visualization for the given state.\n\"\"\"\nfunction setup_visualization(adapter::VisualizationAdapter, state)\n    error(\"setup_visualization not implemented for $(typeof(adapter))\")\nend\n\n\"\"\"\n    update_visualization(adapter::VisualizationAdapter, state)\n\nUpdate visualization with current state.\n\"\"\"\nfunction update_visualization(adapter::VisualizationAdapter, state)\n    error(\"update_visualization not implemented for $(typeof(adapter))\")\nend\n\n\"\"\"\n    close_visualization(adapter::VisualizationAdapter)\n\nClean up visualization resources.\n\"\"\"\nfunction close_visualization(adapter::VisualizationAdapter)\n    error(\"close_visualization not implemented for $(typeof(adapter))\")\nend\n\n# Makie-specific implementation\nstruct MakieAdapter <: VisualizationAdapter\n    fig::Any\n    ax::Any\n    point_plot::Any\n    coordinate_text::Any\n    time_text::Any\n    is_setup::Bool\nend\n\nfunction create_makie_adapter()\n    return MakieAdapter(nothing, nothing, nothing, nothing, nothing, false)\nend\n\nfunction setup_visualization(adapter::MakieAdapter, state)\n    if adapter.is_setup\n        return adapter\n    end\n    \n    # Create Makie figure and axis\n    fig = Main.Figure(\n        size = (800, 600),\n        title = \"Point Controller\",\n        figure_padding = 10,\n        fontsize = 12,\n    )\n    \n    ax = Main.Axis(fig[1, 1],\n        xlabel = \"X Coordinate\",\n        ylabel = \"Y Coordinate\",\n        title = \"Interactive Point Control (Use WASD keys)\",\n        aspect = Main.DataAspect(),\n        limits = (-10, 10, -10, 10),\n    )\n    \n    # Create point plot\n    point_plot = Main.scatter!(ax, state.position,\n        color = :red,\n        markersize = 20,\n        marker = :circle,\n        strokewidth = 0,\n    )\n    \n    # Create coordinate text\n    coordinate_text = Main.lift(state.position) do pos\n        x_rounded = round(pos[1], digits = 2)\n        y_rounded = round(pos[2], digits = 2)\n        return \"Position: ($x_rounded, $y_rounded)\"\n    end\n    \n    Main.text!(ax, -9.5, 7.5,\n        text = coordinate_text,\n        fontsize = 12,\n        color = :black,\n        align = (:left, :top),\n    )\n    \n    # Create time text\n    time_text = Main.lift(state.time) do t\n        return \"Time: $(round(t, digits = 1))s\"\n    end\n    \n    Main.text!(ax, -9.5, 8.5,\n        text = time_text,\n        fontsize = 12,\n        color = :blue,\n        align = (:left, :top),\n    )\n    \n    # Add grid\n    ax.xgridvisible = true\n    ax.ygridvisible = true\n    \n    # Display figure\n    Main.display(fig)\n    \n    # Update adapter\n    adapter.fig = fig\n    adapter.ax = ax\n    adapter.point_plot = point_plot\n    adapter.coordinate_text = coordinate_text\n    adapter.time_text = time_text\n    adapter.is_setup = true\n    \n    return adapter\nend\n\nfunction update_visualization(adapter::MakieAdapter, state)\n    # Makie updates automatically via Observables\n    # No explicit update needed\n    return adapter\nend\n\nfunction close_visualization(adapter::MakieAdapter)\n    if adapter.is_setup && adapter.fig !== nothing\n        # Close Makie window\n        try\n            Main.close(adapter.fig)\n        catch e\n            @warn \"Error closing Makie window\" exception = string(e)\n        end\n    end\nend\n\nend # module VisualizationAdapters","category":"page"},{"location":"refactoring_plan/#Step-1.3:-Create-Input-Handler-Module","page":"Refactoring Plan","title":"Step 1.3: Create Input Handler Module","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"Create src/input_handler_core.jl:","category":"page"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"\"\"\"\n# Core Input Handler\n\nInput processing without Makie dependencies.\n\"\"\"\n\nmodule InputHandlerCore\n\nusing Logging\n\nexport handle_key_press, handle_key_release, setup_keyboard_events\nexport InputEvent, InputHandler\n\n\"\"\"\n    InputEvent\n\nRepresents a keyboard input event.\n\"\"\"\nstruct InputEvent\n    key::Char\n    action::Symbol  # :press or :release\n    timestamp::Float64\nend\n\n\"\"\"\n    InputHandler\n\nHandles input events and updates simulation state.\n\"\"\"\nstruct InputHandler\n    event_queue::Vector{InputEvent}\n    is_active::Bool\nend\n\nfunction create_input_handler()\n    return InputHandler(InputEvent[], true)\nend\n\nfunction handle_key_press(key::Char, state)\n    try\n        # Handle quit key\n        if lowercase(key) == 'q'\n            state.should_quit = true\n            return state\n        end\n\n        # Only process WASD keys for movement\n        const KEY_MAPPINGS = Dict(\n            'w' => [0, 1], 's' => [0, -1], 'a' => [-1, 0], 'd' => [1, 0],\n            'W' => [0, 1], 'S' => [0, -1], 'A' => [-1, 0], 'D' => [1, 0]\n        )\n        \n        if haskey(KEY_MAPPINGS, key)\n            add_key!(state, key)\n            @debug \"Key pressed: $key\" context = \"input_handler\"\n        else\n            @debug \"Ignored key: $key\" context = \"input_handler\"\n        end\n\n        return state\n    catch e\n        @warn \"Error processing key press\" exception = string(e)\n        return state\n    end\nend\n\nfunction handle_key_release(key::Char, state)\n    try\n        const KEY_MAPPINGS = Dict(\n            'w' => [0, 1], 's' => [0, -1], 'a' => [-1, 0], 'd' => [1, 0],\n            'W' => [0, 1], 'S' => [0, -1], 'A' => [-1, 0], 'D' => [1, 0]\n        )\n        \n        if haskey(KEY_MAPPINGS, key)\n            remove_key!(state, key)\n            @debug \"Key released: $key\" context = \"input_handler\"\n        else\n            @debug \"Ignored key release: $key\" context = \"input_handler\"\n        end\n\n        return state\n    catch e\n        @warn \"Error processing key release\" exception = string(e)\n        return state\n    end\nend\n\n# Makie-specific input setup (will be moved to MakieAdapter)\nfunction setup_keyboard_events(fig, state)\n    # This function will be implemented in the MakieAdapter\n    # It connects Makie events to the core input handler\nend\n\nend # module InputHandlerCore","category":"page"},{"location":"refactoring_plan/#Step-1.4:-Refactor-Main-Module","page":"Refactoring Plan","title":"Step 1.4: Refactor Main Module","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"Update src/PointController.jl:","category":"page"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"\"\"\"\n# PointController.jl\n\nMain module using the new architecture with separated concerns.\n\"\"\"\n\nmodule PointController\n\n# Core dependencies\nusing Logging\n\n# Include core modules\ninclude(\"core_state.jl\")\ninclude(\"visualization_adapters.jl\")\ninclude(\"input_handler_core.jl\")\n\n# Re-export core functionality\nexport run_point_controller, SimulationState, PhysicsEngine\nexport create_simulation_state, create_physics_engine\n\n\"\"\"\n    run_point_controller()\n\nMain entry point using the new architecture.\n\"\"\"\nfunction run_point_controller()\n    # Check backend\n    if !check_backend_loaded()\n        error(\"No Makie backend detected. Please activate a backend before using PointController.\")\n    end\n\n    # Initialize logging\n    setup_logging(Logging.Info)\n    log_application_start()\n\n    try\n        # Create core simulation components\n        state = create_simulation_state()\n        engine = create_physics_engine()\n        history = create_state_history()\n        \n        # Create and setup visualization\n        adapter = create_makie_adapter()\n        adapter = setup_visualization(adapter, state)\n        \n        # Setup input handling\n        setup_makie_input_events(adapter.fig, state)\n        \n        # Main simulation loop\n        last_update_time = time()\n        update_interval = 1/60  # 60 FPS\n\n        while !state.should_quit\n            current_time = time()\n            \n            if current_time - last_update_time >= update_interval\n                # Update physics\n                apply_physics!(state, engine, update_interval)\n                \n                # Add to history\n                add_to_history!(history, state)\n                \n                # Update visualization (automatic via Observables)\n                update_visualization(adapter, state)\n                \n                last_update_time = current_time\n            end\n            \n            sleep(0.001)  # Small sleep to prevent busy waiting\n        end\n        \n        # Cleanup\n        close_visualization(adapter)\n        log_application_stop()\n        \n    catch e\n        handle_application_error(e)\n        rethrow(e)\n    end\nend\n\n# Helper functions (simplified versions of existing functions)\nfunction check_backend_loaded()\n    # Implementation similar to current version\nend\n\nfunction setup_logging(level)\n    # Implementation similar to current version\nend\n\nfunction log_application_start()\n    @info \"PointController started with new architecture\"\nend\n\nfunction log_application_stop()\n    @info \"PointController stopped\"\nend\n\nfunction setup_makie_input_events(fig, state)\n    # Connect Makie events to core input handler\n    Main.on(Main.events(fig).keyboardbutton) do event\n        key_string = string(event.key)\n        key_char = first(key_string)\n        \n        if event.action == Main.Keyboard.press\n            InputHandlerCore.handle_key_press(key_char, state)\n        elseif event.action == Main.Keyboard.release\n            InputHandlerCore.handle_key_release(key_char, state)\n        end\n    end\nend\n\nfunction handle_application_error(e)\n    @error \"Application error\" exception = string(e)\nend\n\nend # module PointController","category":"page"},{"location":"refactoring_plan/#Phase-2:-Physics-Integration","page":"Refactoring Plan","title":"Phase 2: Physics Integration","text":"","category":"section"},{"location":"refactoring_plan/#Step-2.1:-Enhanced-Physics-Engine","page":"Refactoring Plan","title":"Step 2.1: Enhanced Physics Engine","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"Extend src/core_state.jl with more sophisticated physics:","category":"page"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"# Add to CoreState module\n\n\"\"\"\n    PhysicsModel\n\nDefines the physical laws governing the system.\n\"\"\"\nstruct PhysicsModel\n    gravity::Point2f\n    force_field::Function  # Custom force field\n    constraints::Vector{Constraint}\n    time_step::Float64\nend\n\n\"\"\"\n    Constraint\n\nPhysical constraints (boundaries, etc.)\n\"\"\"\nabstract type Constraint end\n\nstruct BoundaryConstraint <: Constraint\n    min_bounds::Point2f\n    max_bounds::Point2f\nend\n\nstruct SpringConstraint <: Constraint\n    anchor::Point2f\n    spring_constant::Float64\n    rest_length::Float64\nend\n\n# Enhanced physics calculation\nfunction apply_physics!(state::SimulationState, model::PhysicsModel, dt::Float64)\n    pos = state.position[]\n    vel = state.velocity[]\n    \n    # Calculate all forces\n    gravity_force = state.mass * model.gravity\n    damping_force = -state.damping * vel\n    custom_force = model.force_field(pos, vel)\n    \n    # Calculate constraint forces\n    constraint_forces = Point2f(0, 0)\n    for constraint in model.constraints\n        constraint_forces += calculate_constraint_force(constraint, pos, vel)\n    end\n    \n    # Total force\n    total_force = gravity_force + damping_force + custom_force + constraint_forces\n    \n    # Update velocity (F = ma)\n    acceleration = total_force / state.mass\n    new_velocity = vel + acceleration * dt\n    \n    # Update position\n    new_position = pos + new_velocity * dt\n    \n    # Apply constraints\n    new_position = apply_constraints(new_position, model.constraints)\n    \n    # Update state\n    state.position[] = new_position\n    state.velocity[] = new_velocity\n    state.time[] += dt\n    \n    return state\nend\n\nfunction calculate_constraint_force(constraint::BoundaryConstraint, pos, vel)\n    # Boundary constraint force\n    min_bounds, max_bounds = constraint.min_bounds, constraint.max_bounds\n    \n    force = Point2f(0, 0)\n    \n    # X boundary\n    if pos[1] < min_bounds[1]\n        force += Point2f(10.0 * (min_bounds[1] - pos[1]), 0)\n    elseif pos[1] > max_bounds[1]\n        force += Point2f(10.0 * (max_bounds[1] - pos[1]), 0)\n    end\n    \n    # Y boundary\n    if pos[2] < min_bounds[2]\n        force += Point2f(0, 10.0 * (min_bounds[2] - pos[2]))\n    elseif pos[2] > max_bounds[2]\n        force += Point2f(0, 10.0 * (max_bounds[2] - pos[2]))\n    end\n    \n    return force\nend\n\nfunction calculate_constraint_force(constraint::SpringConstraint, pos, vel)\n    # Spring force: F = -k * (x - x0)\n    displacement = pos - constraint.anchor\n    distance = sqrt(displacement[1]^2 + displacement[2]^2)\n    \n    if distance > 0\n        direction = displacement / distance\n        spring_force = -constraint.spring_constant * (distance - constraint.rest_length) * direction\n        return spring_force\n    else\n        return Point2f(0, 0)\n    end\nend\n\nfunction apply_constraints(pos::Point2f, constraints::Vector{Constraint})\n    new_pos = pos\n    \n    for constraint in constraints\n        if constraint isa BoundaryConstraint\n            min_bounds, max_bounds = constraint.min_bounds, constraint.max_bounds\n            new_pos = Point2f(\n                clamp(new_pos[1], min_bounds[1], max_bounds[1]),\n                clamp(new_pos[2], min_bounds[2], max_bounds[2])\n            )\n        end\n    end\n    \n    return new_pos\nend","category":"page"},{"location":"refactoring_plan/#Phase-3:-Bayesian-Extensibility","page":"Refactoring Plan","title":"Phase 3: Bayesian Extensibility","text":"","category":"section"},{"location":"refactoring_plan/#Step-3.1:-Bayesian-State-System","page":"Refactoring Plan","title":"Step 3.1: Bayesian State System","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"Create src/bayesian_state.jl:","category":"page"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"\"\"\"\n# Bayesian State System\n\nBayesian inference for physics parameter estimation.\n\"\"\"\n\nmodule BayesianState\n\nusing Distributions\nusing Observables: Observable\nusing StaticArrays: SVector\n\nconst Point2f = SVector{2, Float32}\n\nexport BayesianSimulationState, BayesianInferenceEngine\nexport evaluate_next_state, update_parameter_estimates\n\n\"\"\"\n    BayesianSimulationState\n\nExtended state system with Bayesian inference capabilities.\n\"\"\"\nmutable struct BayesianSimulationState\n    # Core state\n    position::Observable{Point2f}\n    velocity::Observable{Point2f}\n    time::Observable{Float64}\n    pressed_keys::Observable{Set{Char}}\n    \n    # Physics parameters (with uncertainty)\n    mass::Observable{Normal{Float64}}\n    damping::Observable{Normal{Float64}}\n    \n    # State history for inference\n    history::Vector{Tuple{Point2f, Point2f, Float64}}  # (pos, vel, time)\n    max_history::Int\n    \n    # Bayesian inference engine\n    inference_engine::BayesianInferenceEngine\n    \n    function BayesianSimulationState(;\n        initial_position::Point2f = Point2f(0, 0),\n        prior_mass::Normal{Float64} = Normal(1.0, 0.5),\n        prior_damping::Normal{Float64} = Normal(0.1, 0.05),\n        max_history::Int = 100\n    )\n        return new(\n            Observable(initial_position),\n            Observable(Point2f(0, 0)),\n            Observable(0.0),\n            Observable(Set{Char}()),\n            Observable(prior_mass),\n            Observable(prior_damping),\n            Tuple{Point2f, Point2f, Float64}[],\n            max_history,\n            BayesianInferenceEngine(prior_mass, prior_damping, 0.1, 0.01)\n        )\n    end\nend\n\n\"\"\"\n    BayesianInferenceEngine\n\nHandles Bayesian parameter estimation and prediction.\n\"\"\"\nstruct BayesianInferenceEngine\n    prior_mass::Normal{Float64}\n    prior_damping::Normal{Float64}\n    observation_noise::Float64\n    learning_rate::Float64\nend\n\n\"\"\"\n    evaluate_next_state\n\nEvaluates next state using Bayesian inference and physics.\n\"\"\"\nfunction evaluate_next_state(\n    state::BayesianSimulationState,\n    dt::Float64,\n    input_force::Point2f\n)\n    # 1. Update Bayesian parameter estimates from history\n    updated_mass = update_mass_estimate(state)\n    updated_damping = update_damping_estimate(state)\n    \n    # 2. Predict next state using current physics model\n    current_pos = state.position[]\n    current_vel = state.velocity[]\n    \n    # Get current parameter estimates\n    mass_mean = mean(updated_mass)\n    damping_mean = mean(updated_damping)\n    \n    # Calculate forces\n    gravity = Point2f(0, -9.81)\n    gravity_force = mass_mean * gravity\n    damping_force = -damping_mean * current_vel\n    \n    total_force = input_force + gravity_force + damping_force\n    \n    # Update velocity (F = ma)\n    acceleration = total_force / mass_mean\n    new_velocity = current_vel + acceleration * dt\n    \n    # Update position\n    new_position = current_pos + new_velocity * dt\n    \n    # 3. Update state\n    state.position[] = new_position\n    state.velocity[] = new_velocity\n    state.time[] += dt\n    state.mass[] = updated_mass\n    state.damping[] = updated_damping\n    \n    # 4. Add to history for future inference\n    push!(state.history, (current_pos, current_vel, state.time[]))\n    \n    # Maintain history size\n    if length(state.history) > state.max_history\n        popfirst!(state.history)\n    end\n    \n    return state\nend\n\n\"\"\"\n    update_mass_estimate\n\nUpdate mass estimate using Bayesian inference from state history.\n\"\"\"\nfunction update_mass_estimate(state::BayesianSimulationState)\n    if length(state.history) < 2\n        return state.inference_engine.prior_mass\n    end\n    \n    # Extract mass observations from history\n    observations = extract_mass_observations(state.history)\n    \n    if isempty(observations)\n        return state.mass[]\n    end\n    \n    # Bayesian update (simplified)\n    # In practice, you'd use more sophisticated inference\n    current_mass = state.mass[]\n    new_mean = mean(observations)\n    new_std = std(observations) + state.inference_engine.observation_noise\n    \n    # Update with learning rate\n    alpha = state.inference_engine.learning_rate\n    updated_mean = (1 - alpha) * mean(current_mass) + alpha * new_mean\n    updated_std = max(std(current_mass), new_std)\n    \n    return Normal(updated_mean, updated_std)\nend\n\n\"\"\"\n    update_damping_estimate\n\nUpdate damping estimate using Bayesian inference from state history.\n\"\"\"\nfunction update_damping_estimate(state::BayesianSimulationState)\n    if length(state.history) < 2\n        return state.inference_engine.prior_damping\n    end\n    \n    # Extract damping observations from history\n    observations = extract_damping_observations(state.history)\n    \n    if isempty(observations)\n        return state.damping[]\n    end\n    \n    # Bayesian update (simplified)\n    current_damping = state.damping[]\n    new_mean = mean(observations)\n    new_std = std(observations) + state.inference_engine.observation_noise\n    \n    # Update with learning rate\n    alpha = state.inference_engine.learning_rate\n    updated_mean = (1 - alpha) * mean(current_damping) + alpha * new_mean\n    updated_std = max(std(current_damping), new_std)\n    \n    return Normal(updated_mean, updated_std)\nend\n\n\"\"\"\n    extract_mass_observations\n\nExtract mass-related observations from state history.\n\"\"\"\nfunction extract_mass_observations(history::Vector{Tuple{Point2f, Point2f, Float64}})\n    observations = Float64[]\n    \n    for i in 2:length(history)\n        prev_pos, prev_vel, prev_time = history[i-1]\n        curr_pos, curr_vel, curr_time = history[i]\n        dt = curr_time - prev_time\n        \n        if dt > 0\n            # Calculate observed acceleration\n            velocity_change = curr_vel - prev_vel\n            observed_acceleration = velocity_change / dt\n            \n            # Estimate mass from acceleration (simplified)\n            # In practice, you'd need to know the applied force\n            if norm(observed_acceleration) > 1e-6\n                # Assume some force magnitude for demonstration\n                estimated_mass = 1.0 / norm(observed_acceleration)\n                push!(observations, estimated_mass)\n            end\n        end\n    end\n    \n    return observations\nend\n\n\"\"\"\n    extract_damping_observations\n\nExtract damping-related observations from state history.\n\"\"\"\nfunction extract_damping_observations(history::Vector{Tuple{Point2f, Point2f, Float64}})\n    observations = Float64[]\n    \n    for (pos, vel, time) in history\n        if norm(vel) > 1e-6\n            # Estimate damping from velocity magnitude\n            # This is a simplified approach\n            estimated_damping = 0.1 / norm(vel)\n            push!(observations, estimated_damping)\n        end\n    end\n    \n    return observations\nend\n\nend # module BayesianState","category":"page"},{"location":"refactoring_plan/#Implementation-Timeline","page":"Refactoring Plan","title":"Implementation Timeline","text":"","category":"section"},{"location":"refactoring_plan/#Week-1:-Core-Separation","page":"Refactoring Plan","title":"Week 1: Core Separation","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"[ ] Create core_state.jl module\n[ ] Create visualization_adapters.jl module\n[ ] Create input_handler_core.jl module\n[ ] Refactor PointController.jl to use new architecture\n[ ] Test core functionality without visualization","category":"page"},{"location":"refactoring_plan/#Week-2:-Physics-Integration","page":"Refactoring Plan","title":"Week 2: Physics Integration","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"[ ] Enhance physics engine with constraints\n[ ] Add spring forces and boundary conditions\n[ ] Implement state history management\n[ ] Test physics calculations","category":"page"},{"location":"refactoring_plan/#Week-3:-Bayesian-Extensibility","page":"Refactoring Plan","title":"Week 3: Bayesian Extensibility","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"[ ] Create bayesian_state.jl module\n[ ] Implement parameter estimation\n[ ] Add uncertainty quantification\n[ ] Test Bayesian inference","category":"page"},{"location":"refactoring_plan/#Week-4:-Multi-Platform-Support","page":"Refactoring Plan","title":"Week 4: Multi-Platform Support","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"[ ] Create Pluto adapter\n[ ] Create Plots adapter\n[ ] Add Jupyter notebook support\n[ ] Comprehensive testing","category":"page"},{"location":"refactoring_plan/#Benefits-of-This-Refactoring","page":"Refactoring Plan","title":"Benefits of This Refactoring","text":"","category":"section"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"Separation of Concerns: Core simulation logic is independent of visualization\nTestability: Core logic can be tested without graphics dependencies\nPortability: Works with any visualization system\nScientific Rigor: Proper physics simulation with uncertainty quantification\nEducational Value: Demonstrates Bayesian inference in physical systems\nMaintainability: Clear interfaces and modular design\nExtensibility: Easy to add new features and visualization backends","category":"page"},{"location":"refactoring_plan/","page":"Refactoring Plan","title":"Refactoring Plan","text":"This refactoring plan provides a clear path to achieve your goals while preserving the reactive architecture benefits and adding sophisticated physics simulation capabilities.","category":"page"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Common-Issues","page":"Troubleshooting","title":"Common Issues","text":"","category":"section"},{"location":"troubleshooting/#Backend-Activation-Issues","page":"Troubleshooting","title":"Backend Activation Issues","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"\"No Makie backend activated\"","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"# Solution: Activate a backend before using PointController\nusing GLMakie  # or CairoMakie, WGLMakie\nGLMakie.activate!()\nusing PointController\nrun_point_controller()","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"\"GLMakie backend not activated\"","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"# Solution: Activate GLMakie before using PointController\nusing GLMakie\nGLMakie.activate!()\nusing PointController\nrun_point_controller()","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"\"OpenGL initialization failed\"","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Update graphics drivers to latest version\nVerify OpenGL 3.3+ support: glxinfo | grep \"OpenGL version\" (Linux)\nTry software rendering if hardware acceleration unavailable\nAlternative: Use CairoMakie for headless operation:\nusing CairoMakie\nCairoMakie.activate!()\nusing PointController\nrun_point_controller()","category":"page"},{"location":"troubleshooting/#Display-Issues","page":"Troubleshooting","title":"Display Issues","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Window doesn't appear","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Check display system configuration (DISPLAY variable on Linux)\nVerify X11 forwarding if using SSH: ssh -X username@hostname\nEnsure window manager is running\nAlternative: Use CairoMakie for headless operation","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Black or corrupted window","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Update graphics drivers\nTry different GLMakie backend settings:\nGLMakie.activate!(debugging = true)","category":"page"},{"location":"troubleshooting/#Input-Issues","page":"Troubleshooting","title":"Input Issues","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Keyboard input not working","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Click on the window to ensure it has focus\nCheck for conflicting key bindings in window manager\nVerify keyboard layout is standard QWERTY","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Keys get \"stuck\"","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This is handled automatically when window loses focus\nIf it persists, close and restart the application","category":"page"},{"location":"troubleshooting/#Performance-Issues","page":"Troubleshooting","title":"Performance Issues","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Slow or laggy movement","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Close other graphics-intensive applications\nReduce window size if experiencing lag\nCheck system resource usage (CPU, memory, GPU)\nTry disabling vsync:\nGLMakie.activate!(vsync = false)","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"High CPU usage","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Enable render-on-demand mode:\nGLMakie.activate!(render_on_demand = true)","category":"page"},{"location":"troubleshooting/#Error-Messages","page":"Troubleshooting","title":"Error Messages","text":"","category":"section"},{"location":"troubleshooting/#Graphics-Errors","page":"Troubleshooting","title":"Graphics Errors","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"\"Display system not available\"","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Solution: Use CairoMakie or ensure display system is available\nFor SSH: Enable X11 forwarding or use CairoMakie","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"\"Out of memory error\"","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Solution: Close other applications and restart Julia session","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"\"OpenGL context creation failed\"","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Solution: \n1. Update graphics drivers\n2. Check OpenGL support: glxinfo | grep \"OpenGL\"\n3. Try software rendering: export LIBGL_ALWAYS_SOFTWARE=1\n4. Use CairoMakie as alternative: using CairoMakie; CairoMakie.activate!()","category":"page"},{"location":"troubleshooting/#Julia-Package-Errors","page":"Troubleshooting","title":"Julia Package Errors","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"\"Package not found\"","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"# Solution: Ensure you're in the correct project environment\nusing Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"\"Method not found\"","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"# Solution: Restart Julia session and reload packages\n# Exit Julia and restart, then:\nusing GLMakie  # or your preferred backend\nGLMakie.activate!()\nusing PointController","category":"page"},{"location":"troubleshooting/#Platform-Specific-Issues","page":"Troubleshooting","title":"Platform-Specific Issues","text":"","category":"section"},{"location":"troubleshooting/#Linux","page":"Troubleshooting","title":"Linux","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"X11 Issues","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"# Check if X11 is running\necho $DISPLAY\n\n# Start X11 if needed\nstartx\n\n# For SSH, enable X11 forwarding\nssh -X username@hostname\n\n# Alternative: Use CairoMakie for headless operation","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Wayland Compatibility","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"# Force X11 backend if Wayland causes issues\nexport GDK_BACKEND=x11\nexport QT_QPA_PLATFORM=xcb","category":"page"},{"location":"troubleshooting/#macOS","page":"Troubleshooting","title":"macOS","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Permission Issues","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Grant terminal/Julia permission to control computer in System Preferences\nEnsure accessibility permissions are enabled","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Retina Display Issues","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"# Use appropriate scaling\nGLMakie.activate!(scalefactor = 2.0)","category":"page"},{"location":"troubleshooting/#Windows","page":"Troubleshooting","title":"Windows","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"DirectX Issues","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Update DirectX runtime\nUpdate graphics drivers\nTry OpenGL mode if DirectX fails","category":"page"},{"location":"troubleshooting/#Backend-Specific-Solutions","page":"Troubleshooting","title":"Backend-Specific Solutions","text":"","category":"section"},{"location":"troubleshooting/#GLMakie-Issues","page":"Troubleshooting","title":"GLMakie Issues","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"# Try different GLMakie settings\nGLMakie.activate!(\n    debugging = true,\n    vsync = false,\n    render_on_demand = true\n)","category":"page"},{"location":"troubleshooting/#CairoMakie-Issues","page":"Troubleshooting","title":"CairoMakie Issues","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"# CairoMakie is generally more reliable in headless environments\nusing CairoMakie\nCairoMakie.activate!()","category":"page"},{"location":"troubleshooting/#WGLMakie-Issues","page":"Troubleshooting","title":"WGLMakie Issues","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"# WGLMakie requires a web browser environment\nusing WGLMakie\nWGLMakie.activate!()","category":"page"},{"location":"troubleshooting/#Debug-Mode","page":"Troubleshooting","title":"Debug Mode","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Enable debugging for more detailed error information:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using GLMakie\nGLMakie.activate!(debugging = true)\nusing PointController\n\n# This will provide more verbose error messages\nrun_point_controller()","category":"page"},{"location":"troubleshooting/#Getting-Help","page":"Troubleshooting","title":"Getting Help","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you encounter issues not covered here:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Check existing issues: GitHub Issues\nCreate a new issue with:\nJulia version (versioninfo())\nOperating system\nGraphics card/driver information\nComplete error message\nSteps to reproduce\nBackend being used (GLMakie, CairoMakie, WGLMakie)\nInclude system information:\n# Run this and include output in your issue\nusing InteractiveUtils\nversioninfo()\n\n# For graphics information (Linux)\nrun(`glxinfo | grep \"OpenGL\"`)\n\n# Check which backend is active\nusing PointController\nPointController.get_backend_name()","category":"page"},{"location":"#JuliaTestRocket","page":"Home","title":"JuliaTestRocket","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An interactive Julia application that displays a controllable point using Makie.jl visualization. Control the point's movement using WASD keys with real-time coordinate updates and smooth continuous movement. Built with a backend-agnostic architecture following modern Makie.jl best practices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: PointController Application)","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Interactive Point Visualization: Real-time point rendering using Makie.jl\nBackend-Agnostic Architecture: Works with GLMakie, CairoMakie, or WGLMakie\nWASD Keyboard Controls: Intuitive movement controls with immediate response\nReal-time Coordinate Display: Live coordinate updates as the point moves\nSmooth Continuous Movement: Fluid movement while keys are held down\nDiagonal Movement Support: Natural diagonal movement when multiple keys are pressed\nRobust Error Handling: Comprehensive error handling for graphics and input issues\nPerformance Optimized: Efficient rendering and input processing\nCI/CD Ready: Comprehensive test suite with backend-specific testing strategies","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# First, activate your preferred Makie backend\nusing GLMakie  # or CairoMakie, WGLMakie\nGLMakie.activate!()\n\n# Then use PointController\nusing PointController\nrun_point_controller()","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/bakulev/JuliaTestRocket\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or clone the repository:","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://github.com/bakulev/JuliaTestRocket.git\ncd JuliaTestRocket\njulia --project=. -e \"using Pkg; Pkg.instantiate()\"","category":"page"},{"location":"#System-Requirements","page":"Home","title":"System Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia: Version 1.10 or higher\nFor interactive graphics: OpenGL 3.3+ compatible graphics card and drivers\nFor headless operation: No graphics hardware required","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting-started.md\", \"architecture.md\", \"refactoring_plan.md\", \"api.md\", \"examples.md\", \"troubleshooting.md\"]","category":"page"}]
}
